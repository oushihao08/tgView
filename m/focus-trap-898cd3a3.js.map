{"version":3,"file":"focus-trap-898cd3a3.js","sources":["../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/utils/vue/refs.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/hooks/use-escape-keydown/index.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/components/focus-trap/src/tokens.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/components/focus-trap/src/utils.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/components/focus-trap/src/focus-trap.mjs"],"sourcesContent":["import '../types.mjs';\nimport { isFunction } from '@vue/shared';\n\nconst composeRefs = (...refs) => {\n  return (el) => {\n    refs.forEach((ref) => {\n      if (isFunction(ref)) {\n        ref(el);\n      } else {\n        ref.value = el;\n      }\n    });\n  };\n};\n\nexport { composeRefs };\n//# sourceMappingURL=refs.mjs.map\n","import { onMounted, onBeforeUnmount } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../constants/index.mjs';\nimport { EVENT_CODE } from '../../constants/aria.mjs';\n\nlet registeredEscapeHandlers = [];\nconst cachedHandler = (e) => {\n  const event = e;\n  if (event.key === EVENT_CODE.esc) {\n    registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));\n  }\n};\nconst useEscapeKeydown = (handler) => {\n  onMounted(() => {\n    if (registeredEscapeHandlers.length === 0) {\n      document.addEventListener(\"keydown\", cachedHandler);\n    }\n    if (isClient)\n      registeredEscapeHandlers.push(handler);\n  });\n  onBeforeUnmount(() => {\n    registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);\n    if (registeredEscapeHandlers.length === 0) {\n      if (isClient)\n        document.removeEventListener(\"keydown\", cachedHandler);\n    }\n  });\n};\n\nexport { useEscapeKeydown };\n//# sourceMappingURL=index.mjs.map\n","const FOCUS_AFTER_TRAPPED = \"focus-trap.focus-after-trapped\";\nconst FOCUS_AFTER_RELEASED = \"focus-trap.focus-after-released\";\nconst FOCUSOUT_PREVENTED = \"focus-trap.focusout-prevented\";\nconst FOCUS_AFTER_TRAPPED_OPTS = {\n  cancelable: true,\n  bubbles: false\n};\nconst FOCUSOUT_PREVENTED_OPTS = {\n  cancelable: true,\n  bubbles: false\n};\nconst ON_TRAP_FOCUS_EVT = \"focusAfterTrapped\";\nconst ON_RELEASE_FOCUS_EVT = \"focusAfterReleased\";\nconst FOCUS_TRAP_INJECTION_KEY = Symbol(\"elFocusTrap\");\n\nexport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS, FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_TRAP_INJECTION_KEY, ON_RELEASE_FOCUS_EVT, ON_TRAP_FOCUS_EVT };\n//# sourceMappingURL=tokens.mjs.map\n","import { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\n\nconst focusReason = ref();\nconst lastUserFocusTimestamp = ref(0);\nconst lastAutomatedFocusTimestamp = ref(0);\nlet focusReasonUserCount = 0;\nconst obtainAllFocusableElements = (element) => {\n  const nodes = [];\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode())\n    nodes.push(walker.currentNode);\n  return nodes;\n};\nconst getVisibleElement = (elements, container) => {\n  for (const element of elements) {\n    if (!isHidden(element, container))\n      return element;\n  }\n};\nconst isHidden = (element, container) => {\n  if (process.env.NODE_ENV === \"test\")\n    return false;\n  if (getComputedStyle(element).visibility === \"hidden\")\n    return true;\n  while (element) {\n    if (container && element === container)\n      return false;\n    if (getComputedStyle(element).display === \"none\")\n      return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nconst getEdges = (container) => {\n  const focusable = obtainAllFocusableElements(container);\n  const first = getVisibleElement(focusable, container);\n  const last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nconst isSelectable = (element) => {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nconst tryFocus = (element, shouldSelect) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement;\n    element.focus({ preventScroll: true });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  const copy = [...list];\n  const idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nconst createFocusableStack = () => {\n  let stack = [];\n  const push = (layer) => {\n    const currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  const remove = (layer) => {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push,\n    remove\n  };\n};\nconst focusFirstDescendant = (elements, shouldSelect = false) => {\n  const prevFocusedElement = document.activeElement;\n  for (const element of elements) {\n    tryFocus(element, shouldSelect);\n    if (document.activeElement !== prevFocusedElement)\n      return;\n  }\n};\nconst focusableStack = createFocusableStack();\nconst isFocusCausedByUserEvent = () => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst useFocusReason = () => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(() => {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp\n  };\n};\nconst createFocusOutPreventedEvent = (detail) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail\n  });\n};\n\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };\n//# sourceMappingURL=utils.mjs.map\n","import { defineComponent, ref, provide, watch, unref, nextTick, onMounted, onBeforeUnmount, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { useFocusReason, getEdges, createFocusOutPreventedEvent, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements, isFocusCausedByUserEvent } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\n\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      default: \"first\"\n    }\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    \"focusin\",\n    \"focusout\",\n    \"focusout-prevented\",\n    \"release-requested\"\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref();\n    let lastFocusBeforeTrapped;\n    let lastFocusAfterTrapped;\n    const { focusReason } = useFocusReason();\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = (e) => {\n      if (!props.loop && !props.trapped)\n        return;\n      if (focusLayer.paused)\n        return;\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;\n      const { loop } = props;\n      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop)\n                tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop)\n                tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    watch(() => props.focusTrapEl, (focusTrapEl) => {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, { immediate: true });\n    watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    const trapOnFocus = (e) => {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n    const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);\n    const onFocusIn = (e) => {\n      const trapContainer = unref(forwardRef);\n      if (!trapContainer)\n        return;\n      const target = e.target;\n      const relatedTarget = e.relatedTarget;\n      const isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap)\n        emit(\"focusin\", e);\n      if (focusLayer.paused)\n        return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    const onFocusOut = (e) => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer)\n        return;\n      if (props.trapped) {\n        const relatedTarget = e.relatedTarget;\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        const target = e.target;\n        const isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap)\n          emit(\"focusout\", e);\n      }\n    };\n    async function startTrap() {\n      await nextTick();\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;\n        lastFocusBeforeTrapped = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n          trapContainer.dispatchEvent(focusEvent);\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl;\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl);\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = \"first\";\n                }\n              }\n              if (focusStartEl === \"first\") {\n                focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n              }\n              if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n    }\n    function stopTrap() {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value\n          }\n        });\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !isFocusCausedByUserEvent())) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);\n        focusableStack.remove(focusLayer);\n      }\n    }\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap();\n      }\n      watch(() => props.trapped, (trapped) => {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap();\n      }\n    });\n    return {\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", { handleKeydown: _ctx.onKeydown });\n}\nvar ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\n\nexport { ElFocusTrap as default };\n//# sourceMappingURL=focus-trap.mjs.map\n"],"names":["composeRefs","refs","el","forEach","ref","isFunction","value","registeredEscapeHandlers","cachedHandler","e","event","key","EVENT_CODE","esc","registeredHandler","FOCUS_AFTER_TRAPPED_OPTS","cancelable","bubbles","FOCUSOUT_PREVENTED_OPTS","FOCUS_TRAP_INJECTION_KEY","Symbol","focusReason","lastUserFocusTimestamp","lastAutomatedFocusTimestamp","focusReasonUserCount","obtainAllFocusableElements","element","nodes","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","activeElement","FILTER_ACCEPT","nextNode","push","currentNode","getVisibleElement","elements","container","isHidden","getComputedStyle","visibility","display","parentElement","tryFocus","shouldSelect","focus","prevFocusedElement","preventScroll","window","performance","now","HTMLInputElement","isSelectable","select","removeFromStack","list","item","copy","idx","indexOf","splice","focusableStack","stack","layer","currentLayer","pause","unshift","remove","_a","_b","resume","call","createFocusableStack","notifyFocusReasonPointer","notifyFocusReasonKeydown","createFocusOutPreventedEvent","detail","CustomEvent","ElFocusTrap","_export_sfc","defineComponent","name","inheritAttrs","props","loop","Boolean","trapped","focusTrapEl","Object","focusStartEl","String","default","emits","setup","emit","forwardRef","lastFocusBeforeTrapped","lastFocusAfterTrapped","onMounted","addEventListener","onBeforeUnmount","removeEventListener","handler","focusLayer","paused","length","isClient","filter","this","onKeydown","altKey","ctrlKey","metaKey","currentTarget","shiftKey","isTabbing","tab","currentFocusingEl","first","last","focusable","reverse","getEdges","includes","focusoutPreventedEvent","defaultPrevented","preventDefault","provide","focusTrapRef","watch","immediate","forwardRef2","oldForwardRef","onFocusIn","onFocusOut","trapOnFocus","releaseOnFocus","trapContainer","unref","target","relatedTarget","isFocusedInTrap","contains","isNil","setTimeout","async","startTrap","nextTick","focusEvent","Event","dispatchEvent","isString","focusFirstDescendant","stopTrap","releasedEvent","body","_ctx","_cache","$props","$setup","$data","$options","renderSlot","$slots","handleKeydown"],"mappings":"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"}