{"version":3,"file":"focus-trap-legacy-d9e8daf6.js","sources":["../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/utils/vue/refs.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/hooks/use-escape-keydown/index.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/components/focus-trap/src/tokens.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/components/focus-trap/src/utils.mjs","../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.38/node_modules/element-plus/es/components/focus-trap/src/focus-trap.mjs"],"sourcesContent":["import '../types.mjs';\nimport { isFunction } from '@vue/shared';\n\nconst composeRefs = (...refs) => {\n  return (el) => {\n    refs.forEach((ref) => {\n      if (isFunction(ref)) {\n        ref(el);\n      } else {\n        ref.value = el;\n      }\n    });\n  };\n};\n\nexport { composeRefs };\n//# sourceMappingURL=refs.mjs.map\n","import { onMounted, onBeforeUnmount } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../constants/index.mjs';\nimport { EVENT_CODE } from '../../constants/aria.mjs';\n\nlet registeredEscapeHandlers = [];\nconst cachedHandler = (e) => {\n  const event = e;\n  if (event.key === EVENT_CODE.esc) {\n    registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));\n  }\n};\nconst useEscapeKeydown = (handler) => {\n  onMounted(() => {\n    if (registeredEscapeHandlers.length === 0) {\n      document.addEventListener(\"keydown\", cachedHandler);\n    }\n    if (isClient)\n      registeredEscapeHandlers.push(handler);\n  });\n  onBeforeUnmount(() => {\n    registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);\n    if (registeredEscapeHandlers.length === 0) {\n      if (isClient)\n        document.removeEventListener(\"keydown\", cachedHandler);\n    }\n  });\n};\n\nexport { useEscapeKeydown };\n//# sourceMappingURL=index.mjs.map\n","const FOCUS_AFTER_TRAPPED = \"focus-trap.focus-after-trapped\";\nconst FOCUS_AFTER_RELEASED = \"focus-trap.focus-after-released\";\nconst FOCUSOUT_PREVENTED = \"focus-trap.focusout-prevented\";\nconst FOCUS_AFTER_TRAPPED_OPTS = {\n  cancelable: true,\n  bubbles: false\n};\nconst FOCUSOUT_PREVENTED_OPTS = {\n  cancelable: true,\n  bubbles: false\n};\nconst ON_TRAP_FOCUS_EVT = \"focusAfterTrapped\";\nconst ON_RELEASE_FOCUS_EVT = \"focusAfterReleased\";\nconst FOCUS_TRAP_INJECTION_KEY = Symbol(\"elFocusTrap\");\n\nexport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS, FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_TRAP_INJECTION_KEY, ON_RELEASE_FOCUS_EVT, ON_TRAP_FOCUS_EVT };\n//# sourceMappingURL=tokens.mjs.map\n","import { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\n\nconst focusReason = ref();\nconst lastUserFocusTimestamp = ref(0);\nconst lastAutomatedFocusTimestamp = ref(0);\nlet focusReasonUserCount = 0;\nconst obtainAllFocusableElements = (element) => {\n  const nodes = [];\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode())\n    nodes.push(walker.currentNode);\n  return nodes;\n};\nconst getVisibleElement = (elements, container) => {\n  for (const element of elements) {\n    if (!isHidden(element, container))\n      return element;\n  }\n};\nconst isHidden = (element, container) => {\n  if (process.env.NODE_ENV === \"test\")\n    return false;\n  if (getComputedStyle(element).visibility === \"hidden\")\n    return true;\n  while (element) {\n    if (container && element === container)\n      return false;\n    if (getComputedStyle(element).display === \"none\")\n      return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nconst getEdges = (container) => {\n  const focusable = obtainAllFocusableElements(container);\n  const first = getVisibleElement(focusable, container);\n  const last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nconst isSelectable = (element) => {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nconst tryFocus = (element, shouldSelect) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement;\n    element.focus({ preventScroll: true });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  const copy = [...list];\n  const idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nconst createFocusableStack = () => {\n  let stack = [];\n  const push = (layer) => {\n    const currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  const remove = (layer) => {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push,\n    remove\n  };\n};\nconst focusFirstDescendant = (elements, shouldSelect = false) => {\n  const prevFocusedElement = document.activeElement;\n  for (const element of elements) {\n    tryFocus(element, shouldSelect);\n    if (document.activeElement !== prevFocusedElement)\n      return;\n  }\n};\nconst focusableStack = createFocusableStack();\nconst isFocusCausedByUserEvent = () => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst useFocusReason = () => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(() => {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp\n  };\n};\nconst createFocusOutPreventedEvent = (detail) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail\n  });\n};\n\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };\n//# sourceMappingURL=utils.mjs.map\n","import { defineComponent, ref, provide, watch, unref, nextTick, onMounted, onBeforeUnmount, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { useFocusReason, getEdges, createFocusOutPreventedEvent, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements, isFocusCausedByUserEvent } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\n\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      default: \"first\"\n    }\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    \"focusin\",\n    \"focusout\",\n    \"focusout-prevented\",\n    \"release-requested\"\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref();\n    let lastFocusBeforeTrapped;\n    let lastFocusAfterTrapped;\n    const { focusReason } = useFocusReason();\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = (e) => {\n      if (!props.loop && !props.trapped)\n        return;\n      if (focusLayer.paused)\n        return;\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;\n      const { loop } = props;\n      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop)\n                tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop)\n                tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    watch(() => props.focusTrapEl, (focusTrapEl) => {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, { immediate: true });\n    watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    const trapOnFocus = (e) => {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n    const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);\n    const onFocusIn = (e) => {\n      const trapContainer = unref(forwardRef);\n      if (!trapContainer)\n        return;\n      const target = e.target;\n      const relatedTarget = e.relatedTarget;\n      const isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap)\n        emit(\"focusin\", e);\n      if (focusLayer.paused)\n        return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    const onFocusOut = (e) => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer)\n        return;\n      if (props.trapped) {\n        const relatedTarget = e.relatedTarget;\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        const target = e.target;\n        const isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap)\n          emit(\"focusout\", e);\n      }\n    };\n    async function startTrap() {\n      await nextTick();\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;\n        lastFocusBeforeTrapped = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n          trapContainer.dispatchEvent(focusEvent);\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl;\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl);\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = \"first\";\n                }\n              }\n              if (focusStartEl === \"first\") {\n                focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n              }\n              if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n    }\n    function stopTrap() {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value\n          }\n        });\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !isFocusCausedByUserEvent())) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);\n        focusableStack.remove(focusLayer);\n      }\n    }\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap();\n      }\n      watch(() => props.trapped, (trapped) => {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap();\n      }\n    });\n    return {\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", { handleKeydown: _ctx.onKeydown });\n}\nvar ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\n\nexport { ElFocusTrap as default };\n//# sourceMappingURL=focus-trap.mjs.map\n"],"names":["exports","refs","forEach","ref","isFunction","el","value","registeredEscapeHandlers","cachedHandler","e","event","key","EVENT_CODE","esc","registeredHandler","FOCUS_AFTER_TRAPPED","FOCUS_AFTER_RELEASED","FOCUS_AFTER_TRAPPED_OPTS","cancelable","bubbles","FOCUSOUT_PREVENTED_OPTS","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","FOCUS_TRAP_INJECTION_KEY","Symbol","lastUserFocusTimestamp","lastAutomatedFocusTimestamp","focusReasonUserCount","obtainAllFocusableElements","element","nodes","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","activeElement","FILTER_ACCEPT","walker","nextNode","push","currentNode","elements","container","isHidden","getComputedStyle","visibility","display","parentElement","tryFocus","shouldSelect","focus","prevFocusedElement","preventScroll","window","performance","now","HTMLInputElement","isSelectable","select","removeFromStack","list","item","copy","idx","indexOf","splice","focusableStack","stack","layer","currentLayer","pause","unshift","remove","_a","_b","resume","call","createFocusableStack","notifyFocusReasonPointer","focusReason","notifyFocusReasonKeydown","useFocusReason","onMounted","addEventListener","onBeforeUnmount","removeEventListener","detail","CustomEvent","_sfc_main","defineComponent","name","inheritAttrs","props","loop","Boolean","trapped","focusTrapEl","Object","focusStartEl","String","default","emits","setup","emit","forwardRef","lastFocusBeforeTrapped","lastFocusAfterTrapped","handler","focusLayer","paused","length","isClient","filter","this","onKeydown","altKey","ctrlKey","metaKey","currentTarget","shiftKey","isTabbing","tab","currentFocusingEl","first","last","focusable","getVisibleElement","reverse","getEdges","includes","createFocusOutPreventedEvent","focusoutPreventedEvent","defaultPrevented","preventDefault","provide","focusTrapRef","watch","immediate","forwardRef2","oldForwardRef","onFocusIn","onFocusOut","trapOnFocus","releaseOnFocus","trapContainer","unref","target","relatedTarget","isFocusedInTrap","contains","isNil","setTimeout","async","startTrap","nextTick","focusEvent","Event","dispatchEvent","isString","focusFirstDescendant","stopTrap","releasedEvent","body","_export_sfc","_ctx","_cache","$props","$setup","$data","$options","renderSlot","$slots","handleKeydown"],"mappings":"0XAGiBA,EAAA,KAAG,IAAIC,QAEpBA,EAAKC,SAASC,IACRC,EAAWD,GACbA,EAAIE,GAEJF,EAAIG,MAAQD,CACb,GALH,ICAJ,IAAIE,EAA2B,GAC/B,MAAmBC,EAAIC,IACrB,MAAMC,EAAQD,EACVC,EAAMC,MAAQC,EAAWC,KAC3BN,EAAyBL,SAASY,GAAsBA,EAAkBJ,IAC3E,ECVsBK,EAAG,iCACtBC,EAAuB,kCAEvBC,EAA2B,CAC/BC,YAAY,EACZC,SAAS,GAEkBC,EAAG,CAC9BF,YAAY,EACZC,SAAS,GAEYE,EAAG,oBACAC,EAAG,qBACCC,EAAAvB,EAAA,IAAGwB,OAAO,kBCVpBrB,IACQsB,EAAGtB,EAAI,GAC7BuB,EAA8BvB,EAAI,GACxC,IAAwBwB,EAAG,EAC3B,MAAgCC,EAAIC,IAClC,MAAMC,EAAQ,KACCC,SAASC,iBAAiBH,EAASI,WAAWC,aAAc,CACzEC,WAAaC,IACX,MAAmBC,EAAoB,UAAjBD,EAAKE,SAAqC,WAAdF,EAAKG,KACvD,OAAIH,EAAKI,UAAYJ,EAAKK,QAAUJ,EACjBJ,WAACS,YACTN,EAACO,UAAY,GAAKP,IAASL,SAASa,cAAgBX,WAAWY,cAAgBZ,WAAWS,WAArG,IAGJ,KAAOI,EAAOC,YACZjB,EAAMkB,KAAKF,EAAOG,aACpB,OAAOnB,CAAP,IAEwB,CAACoB,EAAUC,KACnC,IAAK,WAAiBD,EACpB,IAAKE,EAASvB,EAASsB,GACrB,OAAAtB,CACH,EAEGuB,EAAW,CAACvB,EAASsB,KAGzB,GAA6C,WAAzCE,iBAAiBxB,GAASyB,WAC5B,OAAO,EACT,KAAOzB,GAAS,CACd,GAAIsB,GAAatB,IAAYsB,EAC3B,OAAA,EACF,GAA0C,SAAtCE,iBAAiBxB,GAAS0B,QAC5B,OAAO,EACT1B,EAAUA,EAAQ2B,aACnB,CACD,OAAO,CAAP,EAWIC,EAAW,CAAC5B,EAAS6B,KACzB,GAAI7B,GAAWA,EAAQ8B,MAAO,CAC5B,MAAMC,EAAqB7B,SAASa,cACpCf,EAAQ8B,MAAM,CAAEE,eAAe,IAC/BnC,EAA4BpB,MAAQwD,OAAOC,YAAYC,MACnDnC,IAAY+B,GARE/B,IACNA,aAAPoC,kBAAuC,WAAYpC,EAOlBqC,CAAarC,IAAY6B,GAC7D7B,EAAQsC,QAEX,GAEH,SAASC,EAAgBC,EAAMC,GAC7B,MAAUC,EAAG,IAAIF,GACRG,EAAGH,EAAKI,QAAQH,GAIzB,OAHa,IAATE,GACFD,EAAKG,OAAOF,EAAK,GAEZD,CACR,CACD,MA4BoBI,EA5BS,MAC3B,IAASC,EAAG,GAcZ,MAAO,CACL5B,KAdY6B,IACZ,QAAqBD,EAAM,GACvBE,GAAgBD,IAAUC,GAC5BA,EAAaC,QAEfH,EAAQR,EAAgBQ,EAAOC,GAC/BD,EAAMI,QAAQH,EAAd,EASAI,OAPcJ,IACd,IAAIK,EAAIC,EACRP,EAAQR,EAAgBQ,EAAOC,GACwB,OAAtDM,EAAwB,OAAlBD,EAAKN,EAAM,SAAc,EAASM,EAAGE,SAA2BD,EAAGE,KAAKH,EAA/E,EAEF,EAaqBI,GAIOC,EAAG,KAC/BC,EAAYlF,MAAQ,UACpBmB,EAAuBnB,MAAQwD,OAAOC,YAAYC,KAAlD,EAE4ByB,EAAG,KAC/BD,EAAYlF,MAAQ,WACpBmB,EAAuBnB,MAAQwD,OAAOC,YAAYC,KAAlD,EAEkB0B,EAAG,KACrBC,GAAU,KACqB,IAAzBhE,IACFI,SAAS6D,iBAAiB,YAAaL,GACvCxD,SAAS6D,iBAAiB,aAAcL,GACxCxD,SAAS6D,iBAAiB,UAAWH,IAEvC9D,GACD,IACDkE,GAAgB,KACdlE,IACIA,GAAwB,IAC1BI,SAAS+D,oBAAoB,YAAaP,GAC1CxD,SAAS+D,oBAAoB,aAAcP,GAC3CxD,SAAS+D,oBAAoB,UAAWL,GACzC,IAEI,CACLD,cACA/D,yBACAC,kCAGkCqE,GAC7B,IAAAC,YDlIkB,gCCkIkB,IACtC5E,EACH2E,WC1HWE,EAAGC,EAAgB,CAChCC,KAAM,cACNC,cAAc,EACdC,MAAO,CACLC,KAAMC,QACNC,QAASD,QACTE,YAAaC,OACbC,aAAc,CACZpE,KAAM,CAACmE,OAAQE,QACfC,QAAS,UAGbC,MAAO,CACLzF,EACAC,EACA,UACA,WACA,qBACA,qBAEFyF,MAAMV,GAAOW,KAAEA,IACb,MAAMC,EAAa9G,IACnB,IAAA+G,EACIC,EACJ,MAAM3B,YAAEA,GAAgBE,IHxBF0B,QGyBJ1G,IACZ2F,EAAMG,UAAYa,EAAWC,QAC/BN,EAAK,oBAAqBtG,EAC3B,EH3BLiF,GAAU,KACgC,IAApCpF,EAAyBgH,QAC3BxF,SAAS6D,iBAAiB,UAAWpF,GAEnCgH,GACFjH,EAAyByC,KAAKoE,EACjC,IACDvB,GAAgB,KACdtF,EAA2BA,EAAyBkH,QAAQ3G,GAAsBA,IAAsBsG,IAChE,IAApC7G,EAAyBgH,QACvBC,GACFzF,SAAS+D,oBAAoB,UAAWtF,EAC3C,IGiBD,MAAgB6G,EAAG,CACjBC,QAAQ,EACRvC,QACE2C,KAAKJ,QAAS,CACf,EACDlC,SACEsC,KAAKJ,QAAS,CACf,GAEGK,EAAalH,IACjB,IAAK4F,EAAMC,OAASD,EAAMG,QACxB,OACF,GAAIa,EAAWC,OACb,OACF,MAAM3G,IAAEA,EAAFiH,OAAOA,EAAPC,QAAeA,EAAfC,QAAwBA,EAAxBC,cAAiCA,EAAjCC,SAAgDA,GAAavH,GAC7D6F,KAAEA,GAASD,EACF4B,EAAGtH,IAAQC,EAAWsH,MAAQN,IAAWC,IAAYC,EAC7CK,EAAGpG,SAASa,cACnC,GAAIqF,GAAaE,EAAmB,CAClC,MAAehF,EAAG4E,GACXK,EAAOC,GDrBJlF,KAChB,MAAMmF,EAAY1G,EAA2BuB,GAG7C,MAAO,CAFOoF,EAAkBD,EAAWnF,GAC9BoF,EAAkBD,EAAUE,UAAWrF,GACpD,ECiB4BsF,CAAStF,GAE/B,GADmBiF,GAASC,EAY1B,GAAKL,GAAYG,IAAsBE,GAU5BL,GAAAA,GAAY,CAACI,EAAOjF,GAAWuF,SAASP,GAAoB,CACrE,QAA+BQ,EAA6B,CAC1DnD,YAAaA,EAAYlF,QAE3B0G,EAAK,qBAAsB4B,GACtBA,EAAuBC,mBAC1BpI,EAAEqI,iBACExC,GACF7C,EAAS4E,GAAM,GAEpB,MApB4C,CAC3C,MAAMO,EAAyBD,EAA6B,CAC1DnD,YAAaA,EAAYlF,QAE3B0G,EAAK,qBAAsB4B,GACtBA,EAAuBC,mBAC1BpI,EAAEqI,iBACExC,GACF7C,EAAS2E,GAAO,GAErB,MApBD,GAAID,IAAsBhF,EAAW,CACnC,MAAMyF,EAAyBD,EAA6B,CAC1DnD,YAAaA,EAAYlF,QAE3B0G,EAAK,qBAAsB4B,GACtBA,EAAuBC,kBAC1BpI,EAAEqI,gBAEL,CAwBJ,GAEHC,EAAQxH,EAA0B,CAChCyH,aAAc/B,EACdU,cAEFsB,GAAM,IAAM5C,EAAMI,cAAcA,IAC1BA,IACFQ,EAAW3G,MAAQmG,EACpB,GACA,CAAEyC,WAAW,IAChBD,EAAM,CAAChC,IAAa,EAAEkC,IAAeC,MAC/BD,IACFA,EAAYvD,iBAAiB,UAAW+B,GACxCwB,EAAYvD,iBAAiB,UAAWyD,GACxCF,EAAYvD,iBAAiB,WAAY0D,IAEvCF,IACFA,EAActD,oBAAoB,UAAW6B,GAC7CyB,EAActD,oBAAoB,UAAWuD,GAC7CD,EAActD,oBAAoB,WAAYwD,GAC/C,IAEH,MAAMC,EAAe9I,IACnBuG,EAAK3F,EAAmBZ,EAAxB,EAEI+I,EAAkB/I,GAAMuG,EAAK1F,EAAsBb,GACnD4I,EAAa5I,IACjB,MAAmBgJ,EAAGC,EAAMzC,GAC5B,IAAKwC,EACH,OACF,MAAME,EAASlJ,EAAEkJ,OACXC,EAAgBnJ,EAAEmJ,cAClBC,EAAkBF,GAAUF,EAAcK,SAASH,GACpDtD,EAAMG,SACmBoD,GAAiBH,EAAcK,SAASF,KAElE1C,EAAyB0C,GAGzBC,GACF7C,EAAK,UAAWvG,GACd4G,EAAWC,QAEXjB,EAAMG,UACJqD,EACF1C,EAAwBwC,EAExBlG,EAAS0D,GAAuB,GAEnC,EAEamC,EAAI7I,IAClB,QAAsBiJ,EAAMzC,GAC5B,IAAII,EAAWC,QAAWmC,EAE1B,GAAIpD,EAAMG,QAAS,CACjB,MAAMoD,EAAgBnJ,EAAEmJ,cACnBG,EAAMH,IAAmBH,EAAcK,SAASF,IACnDI,YAAW,KACT,IAAK3C,EAAWC,QAAUjB,EAAMG,QAAS,CACvC,QAA+BmC,EAA6B,CAC1DnD,YAAaA,EAAYlF,QAE3B0G,EAAK,qBAAsB4B,GACtBA,EAAuBC,kBAC1BpF,EAAS0D,GAAuB,EAEnC,IACA,EAEN,KAAM,CACL,MAAYwC,EAAGlJ,EAAEkJ,OACOA,GAAUF,EAAcK,SAASH,IAEvD3C,EAAK,WAAYvG,EACpB,GAEHwJ,eAAeC,UACCC,IACd,MAAmBV,EAAGC,EAAMzC,GAC5B,GAAIwC,EAAe,CACjB9E,EAAe3B,KAAKqE,GACpB,MAAMzD,EAAqB6F,EAAcK,SAAS/H,SAASa,eAAiBsE,EAAyBnF,SAASa,cAG9G,GAFAsE,EAAyBtD,GACI6F,EAAcK,SAASlG,GACzB,CACzB,MAAgBwG,EAAG,IAAIC,MAAMtJ,EAAqBE,GAClDwI,EAAc7D,iBAAiB7E,EAAqBwI,GACpDE,EAAca,cAAcF,GACvBA,EAAWvB,kBACdsB,GAAS,KACP,IAAgBxD,EAAGN,EAAMM,aACpB4D,EAAS5D,KACZlD,EAASkD,GACL5E,SAASa,gBAAkB+D,IAC7BA,EAAe,UAGE,UAAjBA,GD5GW,EAACzD,EAAUQ,GAAe,KACrD,QAA2B3B,SAASa,cACpC,IAAK,MAALf,OAEE,GADA4B,EAAS5B,EAAS6B,GACd3B,SAASa,gBAAkBgB,EAC7B,MACH,ECuGa4G,CAAqB5I,EAA2B6H,IAAgB,GAE9D1H,SAASa,gBAAkBgB,GAAuC,cAAjB+C,GACnDlD,EAASgG,EACV,GAGN,CACF,CACF,CACD,SAASgB,IACP,MAAMhB,EAAgBC,EAAMzC,GAC5B,GAAIwC,EAAe,CACjBA,EAAc3D,oBAAoB/E,EAAqBwI,GACvD,QAAsB,IAAAvD,YAAgBhF,EAAsB,IACvDC,EACH8E,OAAQ,CACNP,YAAaA,EAAYlF,SAG7BmJ,EAAc7D,iBAAiB5E,EAAsBwI,GACrDC,EAAca,cAAcI,GACvBA,EAAc7B,kBAA0C,YAArBrD,EAAYlF,ODzH7BmB,EAACnB,MAAQoB,EAA4BpB,OC0H1DmD,EAAmC,MAA1ByD,EAAiCA,EAAyBnF,SAAS4I,MAE9ElB,EAAc3D,oBAAoB9E,EAAsBuI,GACxD5E,EAAeM,OAAOoC,EACvB,CACF,CAkBD,OAjBA1B,GAAU,KACJU,EAAMG,SACR0D,IAEFjB,GAAM,IAAM5C,EAAMG,UAAUA,IACtBA,EACF0D,IAEAO,GACD,GALH,IAQF5E,GAAgB,KACVQ,EAAMG,SACRiE,GACD,IAEI,CACL9C,YAEH,IAKe3H,EAAA,IAAgB4K,EAAY3E,EAAW,CAAC,CAAC,SAH3D,SAAqB4E,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAWN,EAAKO,OAAQ,UAAW,CAAEC,cAAeR,EAAKlD,WACjE,GACkF,CAAC,SAAU"}